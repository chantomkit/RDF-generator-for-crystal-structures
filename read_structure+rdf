import math
import numpy as np
import matplotlib.pyplot as plt

lattice_cnst = 0
# Basis vector of the unit cell of lattice (x1, y1, z1, x2, y2, z2, x3, y3, z3)
lattice_vector = np.array([])
# Atom type (Element1, Element2, ...)
atom_type = np.array([])
# Atom type (# of Element1, # of Element2, ...)
atom_number = np.array([])
# Atom position (x1, y1, z1, x2, y2, z2, x3, y3, z3, ...)
r = np.array([])
# Rescaled position (x1', y1', z1', x2', y2', z2', x3', y3', z3', ...)
r_rescaled = np.array([])
filename = '195-2-16-SiCl3-r0-id12-20191127-121044'
line = 0

fp = open(filename + ".vasp", "r")
if fp.mode == "r":
    for x in fp:
        line = line + 1
fp.close()

fp = open(filename + ".vasp", "r")
for x in range(1, line + 1):
    # Lattice constant:
    if x == 2:
        lattice_cnst = float(fp.readline())
    # Lattice vector 1:
    elif x >= 3 and x <= 5:
        lattice_vector = np.append(lattice_vector, fp.readline().split(' '))
        # Removing redundant elements
        lattice_vector = lattice_vector[lattice_vector != '']
        lattice_vector = lattice_vector[lattice_vector != '\n']
        lattice_vector = lattice_vector.astype(np.float)
    # Atom type:
    elif x == 6:
        atom_type = np.append(atom_type, fp.readline().split(' '))
        # Removing redundant elements
        atom_type = atom_type[atom_type != '']
        atom_type = atom_type[atom_type != '\n']
    # Atom number
    elif x == 7:
        atom_number = np.append(atom_number, fp.readline().split(' '))
        # Removing redundant elements
        atom_number = atom_number[atom_number != '']
        atom_number = atom_number[atom_number != '\n']
        atom_number = atom_number[atom_number != '0']
        atom_number = atom_number.astype(np.int)
    # Atom position
    elif x >= 10:
        r = np.append(r, fp.readline().split(' '))
        # Removing redundant elements
        r = r[r != '']
        r = r[r != '\n']
        r = r[r != 'T']
        r = r[r != 'T\n']
        r = r.astype(np.float)

    else:
        fp.readline()

for i in atom_number:
    for j in range(0, i * 3 - 1, 3):
        for k in range(0, 8, 3):
            # Dot product for rescaling
            dp = lattice_vector[k] * r[j] + lattice_vector[k + 1] * r[j + 1] + lattice_vector[k + 2] * r[j + 2]
            # Lattice constant factor
            dp = dp * lattice_cnst
            r_rescaled = np.append(r_rescaled, dp)

print("Lattice constant = " + str(lattice_cnst))
print("Number of lines = " + str(line))
print("Lattice vectors = " + str(lattice_vector))
print("Atom type = " + str(atom_type))
print("Atom number = " + str(atom_number))
print("Atom positions = " + str(r))
print("Rescaled atom positions = " + str(r_rescaled))

# For generating structure.xyz for VMD
n = 0
for i in atom_number:
    n = n + i
# Not needed if not interested in generating .xyz file
fp = open("structure_" + filename + ".xyz", "w")
fp.write(str(n))
fp.write("\n\n")
for i in range(len(atom_number)):
    for j in range(0, atom_number[i] * 3 - 1, 3):
        fp.write(str(atom_type[i]) + " " + str(r_rescaled[j]) + " " + str(r_rescaled[j + 1]) + " " + str(r_rescaled[j + 2]) + "\n")
fp.close()

# For RDF
# Macro definitions for spherical shells and bins
dr = 0.01
L1 = math.sqrt(lattice_vector[0] * lattice_vector[0] + lattice_vector[3] * lattice_vector[3] + lattice_vector[6] * lattice_vector[6])
L2 = math.sqrt(lattice_vector[1] * lattice_vector[1] + lattice_vector[4] * lattice_vector[4] + lattice_vector[7] * lattice_vector[7])
L3 = math.sqrt(lattice_vector[2] * lattice_vector[2] + lattice_vector[5] * lattice_vector[5] + lattice_vector[8] * lattice_vector[8])
x = 0
y = 0
z = 0
for i in range(0, 8, 3):
    x = x + lattice_vector[i]
    y = y + lattice_vector[i + 1]
    z = z + lattice_vector[i + 2]
diagonal = np.array([x ,y, z])
RMAX = math.sqrt(diagonal[0] * diagonal[0] + diagonal[1] * diagonal[1] + diagonal[2] * diagonal[2]) / 2
RMIN = 0.005
binmax = int(RMAX / dr)
count = np.zeros((binmax,), dtype=int)
g = np.zeros((binmax,), dtype=float)

# Find separations of atoms and appL2 PBC
for i in range(0, n * 3, 3):
    for j in range(i + 3, n * 3, 3):
        #print(i)
        #print(j)
        delta_r = np.array([r_rescaled[i] - r_rescaled[j], r_rescaled[i + 1] - r_rescaled[j + 1], r_rescaled[i + 2] - r_rescaled[j + 2]])
        # Stores separations of i-th (includes original particle and PBC mirrored particles) and j-th particles
        r_sq = np.zeros((7,), dtype=float)
        for k in range(3):
            r_sq[0] = r_sq[0] + (delta_r[k]) * (delta_r[k])
            r_sq[1] = r_sq[1] + (delta_r[k] + lattice_vector[k]) * (delta_r[k] + lattice_vector[k])
            r_sq[2] = r_sq[2] + (delta_r[k] - lattice_vector[k]) * (delta_r[k] - lattice_vector[k])
            r_sq[3] = r_sq[3] + (delta_r[k] + lattice_vector[k + 3]) * (delta_r[k] + lattice_vector[k + 3])
            r_sq[4] = r_sq[4] + (delta_r[k] - lattice_vector[k + 3]) * (delta_r[k] - lattice_vector[k + 3])
            r_sq[5] = r_sq[5] + (delta_r[k] + lattice_vector[k + 6]) * (delta_r[k] + lattice_vector[k + 6])
            r_sq[6] = r_sq[6] + (delta_r[k] - lattice_vector[k + 6]) * (delta_r[k] - lattice_vector[k + 6])
        #print(r_sq)
        #Classisify into bins
        for x in range(binmax):
            R = float(RMIN + x * dr)
            if r_sq.min() >= (R * R) and r_sq.min() < ((R + dr) * (R + dr)):
                count[x] = count[x] + 1
                break

# RDF formula
for x in range(binmax):
    count[x] = 2 * count[x] / n
    g[x] = (L1 * L2 * L3 / n) * (count[x] / (4 * math.pi * (x * dr + RMIN) * (x * dr + RMIN) * dr))

# Writing in .csv file
fp = open("rdf_" + filename + ".csv", "w")
for x in range(binmax):
    fp.write(str(x * dr + RMIN) + ", " + str(g[x]) + "\n")
fp.close()

# Plotting
x, y = np.loadtxt("rdf_" + filename + ".csv", delimiter=',', unpack=True)
plt.plot(x,y, color='k', markersize=0, linestyle='-', linewidth=1)
plt.title('RDF')
plt.xlabel('r')
plt.ylabel('g(r)')
plt.show()